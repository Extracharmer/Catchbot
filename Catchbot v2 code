#include <AccelStepper.h>
#include <math.h>

// Stepper setup (using Stepper library mode)
#define STEP_PIN 2
#define DIR_PIN 3

AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

// IR sensors
const int IRPin1 = 4;
const int IRPin2 = 5;

// Limit switch for homing
const int limitSwitchPin = 6;

// Timing
unsigned long t1 = 0;
unsigned long t2 = 0;

// Physics constants
const float sensorDistance = 0.065;  // meters
const float y = 0.816;               // height of table
const float g = 9.8;                 // gravity

// Stepper conversion
const float stepsPerMm = 25.0;       // steps per mm
const float mmPerMeter = 1000.0;

// Acceleration and speed limits
const float maxSpeed = 500.0;        // steps per second
const float maxAccel = 1000.0;       // steps per second^2

void setup() {
  Serial.begin(9600);

  // IR sensors and limit switch
  pinMode(IRPin1, INPUT_PULLUP);
  pinMode(IRPin2, INPUT_PULLUP);
  pinMode(limitSwitchPin, INPUT_PULLUP);

  // AccelStepper configuration
  stepper.setMaxSpeed(maxSpeed);
  stepper.setAcceleration(maxAccel);

  // Home platform at startup
  Serial.println("Homing platform...");
  homePlatform();
  Serial.println("Homing complete.");
}

void loop() {
  // Wait for first sensor to break
  while (digitalRead(IRPin1) == HIGH) {}

  t1 = millis();

  // Wait for second sensor to break
  while (digitalRead(IRPin2) == HIGH) {}

  t2 = millis();

  if (t2 > t1) {
    float dt = (t2 - t1) / 1000.0;        // convert ms to seconds
    float vi = sensorDistance / dt;       // horizontal velocity
    float T = sqrt((2 * y) / g);          // fall time
    float x = vi * T;                      // predicted landing distance

    Serial.print("Marble velocity (m/s): ");
    Serial.println(vi);
    Serial.print("Predicted landing distance (m): ");
    Serial.println(x);

    // Convert distance to stepper steps
    long targetPosition = x * mmPerMeter * stepsPerMm;
    Serial.print("Moving platform to steps: ");
    Serial.println(targetPosition);

    stepper.moveTo(targetPosition);

    // Move stepper smoothly to position
    while (stepper.distanceToGo() != 0) {
      stepper.run();
    }
  }

  // Wait until marble clears the sensors
  while (digitalRead(IRPin1) == LOW || digitalRead(IRPin2) == LOW) {}
}

// Homing function
void homePlatform() {
  stepper.setMaxSpeed(200);      // slower for homing
  stepper.setAcceleration(500);

  // Move backward until limit switch pressed
  while (digitalRead(limitSwitchPin) == HIGH) {
    stepper.moveTo(stepper.currentPosition() - 1);
    stepper.run();
  }

  // Back off a few steps to release switch
  stepper.moveTo(stepper.currentPosition() + 5);
  while (stepper.distanceToGo() != 0) stepper.run();

  // Set current position as zero
  stepper.setCurrentPosition(0);

  // Restore normal speed
  stepper.setMaxSpeed(maxSpeed);
  stepper.setAcceleration(maxAccel);
}
