//includes libraries
#include <AccelStepper.h>
#include <math.h>

AccelStepper stepper(AccelStepper::DRIVER, 3, 2); //step 3, dir 2

const int firstSens = 4; //set first ir sensor
const int secondSens = 5; //set second ir sensor

unsigned long firstBeambreak = 0; //time of first "beambreak"
unsigned long secondBeambreak = 0; //time of second "beambreak"
long mStep = 0; //the distance of the y axis converted to steps

float sensTime = 0; //delta time between the sensors triggering
float rampVelocity= 0; //initial horizontal speed off the ramp
float distance = 0; //distance the trolley should move
float fallTime = 0; //time it takes the marble to fall

const float sensDist = 0.04; //distance between sensors (4cm)
const float height = 0.675; //height of table
const float grav = 9.8; //gravity

void setup() {
  Serial.begin(9600);

  pinMode(firstSens, INPUT); //sets pin 4 to read
  pinMode(secondSens, INPUT); //sets pin 5 to read

  stepper.setMaxSpeed(200000.0); //sets the max speed of the stepper
  stepper.setAcceleration(200000.0); //sets the max acceleration of the stepper
  stepper.setCurrentPosition(0); //sets the current position of the stepper as 0


}

void loop() {
  /*if (stepper.distanceToGo()==0)
  stepper.moveTo(-stepper.currentPosition());
  stepper.run();
  */

  if (digitalRead(firstSens) == LOW && firstBeambreak == 0) { //condition: when pin 4 reads low and t1 is reset
    firstBeambreak = millis(); //take timestamp of "beambreak" 1
  }

  if (digitalRead(secondSens) == LOW && firstBeambreak != 0 && secondBeambreak == 0) { //condition: when pin5 reads low and t2 is reset
    secondBeambreak = millis(); //take timestamp of "beambreak" 2
  }

  if (secondBeambreak>firstBeambreak) { //condition: when t2 is larger than t1

    sensTime = (secondBeambreak - firstBeambreak) / 1000.0; //delta time & conversion from milliseconds to seconds
    rampVelocity = sensDist / sensTime; //calculating the horizontal speed off the ramp (v=d/t)
    Serial.println(rampVelocity);

    fallTime = sqrt((2 * height) / grav); //calculates thet ime it takes for the vertical fall off the ramp
    distance = rampVelocity * fallTime; //uses the time to calculate the horizontal distance the marble will go 

    mStep = distance * 100.0 * 50; //meters to steps conversion

    stepper.moveTo(mStep); //go how many steps it determined

    while (stepper.distanceToGo() != 0) { //don't stop the motor until it reaches its destination
      stepper.run(); //run the stepper
    }

    delay(1000); //wait at the catch point

    stepper.moveTo(0); //go back to zero (home)

    while (stepper.distanceToGo() != 0) { //don't stop the motor until it reaches its destination
      stepper.run(); //run the stepper
    }

    firstBeambreak = 0; //reset t1
    secondBeambreak = 0; //reset t2
    mStep = 0; //reset mStep

  }
}
